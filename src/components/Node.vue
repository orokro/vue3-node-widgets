<!--
	Node.vue
	--------

	This will be one of the on screen nodes.

	If the node class specifies just values for its inputs and outputs,
	this will automatically generate the UI and sockets for them.

	However, if the node specifies a custom component, then we'll mount
	that in this element as a container.

	This element will have a title bar that can drag the node around,
	and a close button to remove the node from the graph.
-->
<template>

	<!-- main outer wrapper -->
	<div 
		class="node-box"
		:style="{
			left: `${node.x?.value}em`,
			top: `${node.y?.value}em`,
		}">

		<!-- title -->
		<div 
			class="title-bar"
			@mousedown.stop="startDrag"
		>
			<span>
				{{ node.constructor.nodeName }}
			</span>

			<!-- close button -->
			<div 
				class="delete-button"
				@click.stop.prevent="graph.removeNode(node)"
			>
				<i class="material-icons">close</i>
			</div>
		</div>

		<!-- node content -->
		<div ref="contentEl" class="content">

			<!-- only render this if we don't provide a custom component -->
			<template v-if="node.constructor.customComponent==null">
				<span v-if="node.constructor.fields.length === 0">
					NODE CONTENT.
				</span>
				<div v-else>
					
					<!-- this will spawn the rows of built-in components -->
					<div 
						class="node-field-row"
						:data-type="field.fieldType"
						v-for="(field, index) in node.constructor.fields"
						:key="index"			
					><!-- :setYPos="setYPos(node.fieldState[field.name]?.data.rowEl, field)" -->


						<!-- all node kinds can have labels -->
						<NLabel 
							v-if="field.fieldType == FIELD_TYPE.LABEL"
							:key="index"
							:text="field.text"
							:align="field.align"/>

						<!-- if it wasn't a label then we're build a row for either an INPUT/OUTPUT/PROP -->
						<template v-else>

							<!-- if it's a processing node, or its prop on an input/output we show a field-name row -->
							<div 
								v-if="
									(node.constructor.nodeType == NODE_TYPE.PROCESSING
									||
									field.fieldType == FIELD_TYPE.PROP)
									&&
									!(field.fieldType == FIELD_TYPE.INPUT
									&&
									fieldHasInput(field))
								"
								class="field-name"
								:title="field.description"
							>
								<span>{{ field.title }}</span>
							</div>	

							<!-- area to spawn sockets below -->
							<div :ref="el => setSocketRef(field.name, el)" class="socket-ref-el"/>

							<!-- otherwise, if we're processing node we'll mount it's component-->
							<component
								v-if="showWidgetFor(field)"
								:is="getFieldComponent(field)"
								:key="index"								
								:node="node"
								:field="field"
								:read-only="field.fieldType == FIELD_TYPE.OUTPUT"
							/>

							<!-- otherwise, if it's an input node and an input field, or an output node and an output field
								     then we just show the field name aligned to the socket -->
							<NFieldNameWidget
								v-else
								
								:text="field.title"
								:align="field.fieldType == FIELD_TYPE.INPUT ? 'left' : 'right'"
							/>

						</template>

					</div>

				</div>
			</template>

			<!-- if we have a custom component, we can just mount it here -->
			<template v-else>
				<component
					:is="node.constructor.customComponent"
					:node="node"
					:graph="graph"
				/>
			</template>

			<!-- regardless of weather we used the autogenerated UI or a custom component
			 	 we need to spawn the sockets for the inputs and outputs separately -->
			<template v-if="node.constructor.fields.length !== 0">
				<div class="sockets sockets-inputs">

					<template

						v-for="(field, index) in node.constructor.fields"
						:key="field.id"
					>
						<Socket
							v-if="
								socketPositions.has(`${node.id}::${field.id}`)
								&&
								[FIELD_TYPE.INPUT].includes(field.fieldType)
							"
							:y="socketPositions.get(`${node.id}::${field.id}`).top"
							:node="node"
							:graph="graph"
							:field="field"
							:socketType="SOCKET_TYPE.INPUT"
							:socketStyle="field.valueType.socketStyle"
						/>
					</template>
				</div>
				<div class="sockets sockets-outputs">
					<template

						v-for="(field, index) in node.constructor.fields"
						:key="field.id"
					>
						<Socket
							v-if="
								socketPositions.has(`${node.id}::${field.id}`)
								&&
								node.constructor.nodeType != NODE_TYPE.OUTPUT 
								&& 
								(
									field.fieldType == FIELD_TYPE.OUTPUT
									|| 
									(field.fieldType == FIELD_TYPE.INPUT && field.valuePassThrough)
								)
							"
							:y="socketPositions.get(`${node.id}::${field.id}`).top"
							:node="node"
							:graph="graph"
							:field="field"
							:socketType="SOCKET_TYPE.OUTPUT"
							:socketStyle="field.valueType.socketStyle"
						/>
					</template>
				</div>
			</template>

		</div>
	</div>
</template>
<script setup>

// vue imports
import { ref, onMounted, onUnmounted, nextTick, inject, watch, readonly, computed } from 'vue';

// our app
import { FIELD_TYPE, NODE_TYPE, SOCKET_TYPE } from '@/classes/NWNode';

// components
import NLabel from './TypeWidgets/NLabel.vue';
import Socket from './Socket.vue';
import NFieldNameWidget from './TypeWidgets/NFieldNameWidget.vue';

// props
const props = defineProps({

	// reference to the NWEditor instance
	graph: {
		type: Object,
		required: true
	},

	// the node instance 
	node: {
		type: Object,
		required: true
	}
});

// get our re-usable drag helper
const dh = inject('dh');

// get our global socket positions
const socketPositions = inject('socketPositions');

// get the viewport details for the view we're in
const {
	panX,
	panY,
	zoomScale,
} = inject('viewport');

// a map of the socket row refs for this component
// (instead of storing them on state like we used to)
const fieldRowData = new Map();

// ref to the element where we spawn content
const contentEl = ref(null);

// wires list lives on the editor graph; shallowRef so changes are reactive
const wiresRef = props.graph.wires;


// cache of connected INPUT endpoints, keyed by "nodeId::fieldName"
const connectedInputsKeySet = computed(()=>{

	// force recalc when wires change
	const _ver = props.node.wiresVersion.value;

	// build a set of all connected INPUT endpoints
	const set = new Set();
	for(const c of wiresRef.value){

		// NOTE: a field gets its value when it is the OUTPUT end of a connection
		// (connection.outputNode/outputField is the consumer/input socket)
		if(c?.outputNode && c?.outputField)
			set.add(`${c.outputNode.id}::${c.outputField.name}`);
		
	}// next c

	return set;
});


// helper to set a socket ref for a given field name
function setSocketRef(fieldName, el){

	// otherwise create a new entry
	fieldRowData.set(fieldName, el);
}


// true iff THIS node's given field has an INPUT wire
function fieldHasInput(field){

	return connectedInputsKeySet.value.has(`${props.node.id}::${field.name}`);
}


// only show the widget when:
// - processing node OR PROP field
// - and EITHER it's not an INPUT field OR it is an INPUT without a wire
function showWidgetFor(field){

	// only show widgets for processing nodes or PROP fields
	const isProcOrProp = props.node.constructor.nodeType == NODE_TYPE.PROCESSING || field.fieldType == FIELD_TYPE.PROP;
	if(!isProcOrProp)
		return false;

	// if something is plugged into this input kind, hide the widget
	if(field.fieldType == FIELD_TYPE.INPUT && fieldHasInput(field)) 
		return false;

	// otherwise show the widget
	return true;
}


/**
 * Gets the component to use for a given field.
 * 
 * @param field - the field to get the component for
 * @return The component to use for the field
 */
function getFieldComponent(field){

	// return the fields custom component if it has one, otherwise the valueType's component
	if(field.component!=null)
		return field.component;
	else
		return field.valueType.nodeWidgetComponent;
} 


// when wires change, widgets can appear/disappear → row heights change → remeasure
watch(()=>wiresRef.value, ()=>{
	nextTick(()=>{ measureFieldPositions(); });
});


function setYPos(rowEl, field) {

	nextTick(()=>{
		console.log(rowEl);
		rowEl = rowEl?.value?.[0];

		// if the row element is not defined, return
		if (!rowEl) return;

		// get the offset of the row element in ems relative to its parent
		const offsetInEm = getOffsetInEm(rowEl) + 26;

		// set the input and output Y positions based on the offset
		props.node.fieldState[field.name].data.inputYPos.value = offsetInEm;
		props.node.fieldState[field.name].data.outputYPos.value = offsetInEm;
	});
}


/**
 * Handles the start of dragging the node
 * 
 * @param e - The mouse event that triggered this function
 */
function startDrag(e) {

	// save our nodes initial position
	const initialX = props.node.x.value;
	const initialY = props.node.y.value;

	dh.dragStart(

		(dx, dy) => {

			props.node.setPosition(
				initialX - dx / zoomScale.value,
				initialY - dy / zoomScale.value
			);

			measureFieldPositions();
		},
		(dx, dy) => {

		},
	);

}


/**
 * Gets the offset of a row element in ems relative to its parent element.
 * 
 * @param rowEl - The row element to get the offset for
 * @returns The offset of the row element in ems relative to its parent
 */
function getOffsetInEm(rowEl) {

	const parentEl = contentEl.value;

	// get rectangles for the row element and its parent
	const elRect = rowEl.getBoundingClientRect();
	const parentRect = parentEl.getBoundingClientRect() ?? { top: 0, left: 0, width: 0, height: 0 };

	// calculate the pixel offset of the row element relative to its parent
	const pixelOffset = elRect.top - parentRect.top;

	// convert the pixel offset to ems based on the font size of the row element
	const emSize = parseFloat(getComputedStyle(parentEl).fontSize) || 1;
	return {
			top: pixelOffset / emSize + 9, 
			right: parentRect.width / emSize
	};
}


/**
 * Measures the positions of all fields in the node and sets their input and output Y positions.
 */
function measureFieldPositions(){

	// don't measure if we have a custom component,
	// because it will specify it's own socket positions
	if(props.node.constructor.customComponent!==null)
		return;

	// loop through all the fields in the node
	for (const field of props.node.constructor.fields) {

		// skip non input/output fields
		if (![FIELD_TYPE.INPUT, FIELD_TYPE.OUTPUT].includes(field.fieldType)) {
			continue;
		}

		// get the row element for this field
		// const rowEl = props.node.fieldState[field.name]?.data.rowEl?.value[0];
		const rowEl = fieldRowData.get(field.name);

		if (!rowEl) {
			console.warn(`No row element found for field ${field.name}`);
			continue;
		}
		
		// get the offset of the row element in ems relative to its parent
		const offsetInEm = getOffsetInEm(rowEl);

		// get unique key for these fields
		const key = `${props.node.id}::${field.id}`;
		socketPositions.set(`${key}`, offsetInEm);
	}
}


const viewport = inject('viewport');
watch(()=>viewport.zoomScale.value, (newZoom)=>{
	measureFieldPositions();
});


// resize observer to remeasure field positions when the content element resizes
let ro = null;


// on mount, measure field positions
onMounted(()=>{

	// once initially mounted, measure field positions	
	measureFieldPositions();

	// set up a resize observer to re-measure field positions when the content element resizes
	ro = new ResizeObserver(() => {

		// remeasure field positions
		measureFieldPositions();

	});
	ro.observe(contentEl.value);
});


// clean up resize observer on unmount
onUnmounted(()=>{
	if(ro){
		ro.disconnect();
		ro = null;
	}
});


</script>
<style lang="scss" scoped>

	// the main box
	.node-box {

		// fixed absolute
		position: absolute;
		box-sizing: border-box;

		// minimum box size
		min-width: 160em;
		// min-height: 100em;

		// nice rounded border
		border-radius: 10em;
		border: 2em solid black;

		// padding on top for the title bar
		padding-top: 22em;

		// the title bar for the node that has the close button
		//  & can drag the node around
		.title-bar {

			// fixed position along the top
			position: absolute;
			inset: 0em 0em auto 0em;
			height: 22em;
			box-sizing: border-box;

			// background color
			background: rgba(0, 0, 0, 0.5);

			// same rounded corners at the top
			border-top-left-radius: 7em;
			border-top-right-radius: 7em;

			// look draggable
			cursor: move;

			padding: 3em 20em 0em 7em;
			text-align: left;
			text-wrap: nowrap;
			text-overflow: ellipsis;
			overflow: hidden;

			span {
				font-size: 12em;
				color: white;
				font-weight: bold;
			}

			// the delete button
			.delete-button {
				
				// red round circle
				background	: rgba(0, 0, 0, 0.55);
				border-radius: 50%;
				width: 16em;
				height: 16em;

				// light up on hover
				&:hover {
					background: rgba(255, 0, 0, 0.55);
				}

				// position the close button
				position: absolute;
				inset: 3em 4em 4em auto;

				// make it look like a button
				cursor: pointer;
				color: white;

				i {
					color: white;
					font-size: 14em;
					font-weight: bolder;;
					position: absolute;
					top: 50%;
					left: 50%;
					transform: translate(-50%, -50%);
				
				}// i

			}//.delete-button
			
		}// .title-bar

		// the content area of the node
		.content {

			// fill the rest of the box
			width: 100%;
			height: 100%;

			// padding for the content
			/* padding: 30em; */

			// background color
			background: rgba(255, 255, 255, 0.8);

			border-radius: 0em 0em 7em 7em;

			// the rows where we spawn the individual fields
			.node-field-row {

				padding: 6em 8em 0em 6em;

				background: rgba(0, 0, 0, 0.1);
				&:nth-child(odd) {
					background: rgba(0, 0, 0, 0.15);
				}

				&:last-child {
					padding-bottom: 6em;
				}

				.field-name {

					padding: 6em 6em 0em;

					span {
						padding: 0em;
						font-size: 11em;
						font-style: italic;
						opacity: 0.85;
					}

				}// .field-name

			}// .node-field-row

			span {
				display: block;
				padding: 2em;
				font-size: 16em;
				color: black;
			}

		}// .content

		// the vertical rectangles on either side of the node to house the sockets
		.sockets {

			// for debug
			/* border: 1px solid red; */
			/* background: rgba(0, 0,0, 0.1); */

			// disable pointed events
			position: absolute;
			top: 22em;
			bottom: 0em;
			width: 5em;

			// mount inputs on left, outputs on right
			&.sockets-inputs { left: -1em;	}
			&.sockets-outputs { right: -1em; }

		}// .sockets

	}// .node-box

</style>
